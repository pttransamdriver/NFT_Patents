var _a;
import path from "node:path";
import { assertHardhatInvariant, HardhatError, } from "@nomicfoundation/hardhat-errors";
import { HardhatArtifactResolver, PrettyEventHandler, errorDeploymentResultToExceptionMessage, readDeploymentParameters, resolveDeploymentId, } from "@nomicfoundation/hardhat-ignition/helpers";
import { DeploymentResultType, FutureType, deploy, isContractFuture, } from "@nomicfoundation/ignition-core";
export class ViemIgnitionHelperImpl {
    type = "viem";
    #hardhatConfig;
    #artifactsManager;
    #connection;
    #config;
    #provider;
    constructor(hardhatConfig, artifactsManager, connection, config, provider) {
        this.#hardhatConfig = hardhatConfig;
        this.#artifactsManager = artifactsManager;
        this.#connection = connection;
        this.#config = config;
        this.#provider = provider ?? this.#connection.provider;
    }
    /**
     * Deploys the given Ignition module and returns the results of the module
     * as Viem contract instances.
     *
     * @param ignitionModule - The Ignition module to deploy.
     * @param options - The options to use for the deployment.
     * @returns Viem contract instances for each contract returned by the module.
     */
    async deploy(ignitionModule, { parameters = {}, config: perDeployConfig = {}, defaultSender = undefined, strategy, strategyConfig, deploymentId: givenDeploymentId = undefined, displayUi = false, } = {
        parameters: {},
        config: {},
        defaultSender: undefined,
        strategy: undefined,
        strategyConfig: undefined,
        deploymentId: undefined,
        displayUi: undefined,
    }) {
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- eth_accounts returns a string array
        const accounts = (await this.#connection.provider.request({
            method: "eth_accounts",
        }));
        const artifactResolver = new HardhatArtifactResolver(this.#artifactsManager);
        const resolvedConfig = {
            ...this.#config,
            ...perDeployConfig,
        };
        const resolvedStrategyConfig = _a.#resolveStrategyConfig(this.#hardhatConfig, strategy, strategyConfig);
        const chainId = Number(await this.#connection.provider.request({
            method: "eth_chainId",
        }));
        const deploymentId = resolveDeploymentId(givenDeploymentId, chainId);
        const deploymentDir = this.#connection.networkConfig.type === "edr-simulated"
            ? undefined
            : path.join(this.#hardhatConfig.paths.ignition, "deployments", deploymentId);
        const executionEventListener = displayUi
            ? new PrettyEventHandler()
            : undefined;
        let deploymentParameters;
        if (typeof parameters === "string") {
            deploymentParameters = await readDeploymentParameters(parameters);
        }
        else {
            deploymentParameters = parameters;
        }
        const result = await deploy({
            config: resolvedConfig,
            provider: this.#provider,
            deploymentDir,
            executionEventListener,
            artifactResolver,
            ignitionModule,
            deploymentParameters,
            accounts,
            defaultSender,
            strategy,
            strategyConfig: resolvedStrategyConfig,
            maxFeePerGasLimit: this.#connection.networkConfig?.ignition.maxFeePerGasLimit,
            maxPriorityFeePerGas: this.#connection.networkConfig?.ignition.maxPriorityFeePerGas,
        });
        if (result.type !== DeploymentResultType.SUCCESSFUL_DEPLOYMENT) {
            const message = errorDeploymentResultToExceptionMessage(result);
            throw new HardhatError(HardhatError.ERRORS.IGNITION.INTERNAL.DEPLOYMENT_ERROR, {
                message,
            });
        }
        return this.#toViemContracts(this.#connection, ignitionModule, result);
    }
    async #toViemContracts(connection, ignitionModule, result) {
        return Object.fromEntries(await Promise.all(Object.entries(ignitionModule.results).map(async ([name, contractFuture]) => [
            name,
            await this.#getContract(connection, contractFuture, result.contracts[contractFuture.id]),
        ])));
    }
    async #getContract(connection, future, deployedContract) {
        assertHardhatInvariant(isContractFuture(future), `Expected contract future but got ${future.id} with type ${future.type} instead`);
        return this.#convertContractFutureToViemContract(connection, future, deployedContract);
    }
    async #convertContractFutureToViemContract(connection, future, deployedContract) {
        switch (future.type) {
            case FutureType.NAMED_ARTIFACT_CONTRACT_DEPLOYMENT:
            case FutureType.NAMED_ARTIFACT_LIBRARY_DEPLOYMENT:
            case FutureType.NAMED_ARTIFACT_CONTRACT_AT:
                return this.#convertHardhatContractToViemContract(connection, future, deployedContract);
            case FutureType.CONTRACT_DEPLOYMENT:
            case FutureType.LIBRARY_DEPLOYMENT:
            case FutureType.CONTRACT_AT:
                return this.#convertArtifactToViemContract(connection, future, deployedContract);
        }
    }
    #convertHardhatContractToViemContract(connection, future, deployedContract) {
        return connection.viem.getContractAt(future.contractName, _a.#ensureAddressFormat(deployedContract.address));
    }
    async #convertArtifactToViemContract(connection, future, deployedContract) {
        const publicClient = await connection.viem.getPublicClient();
        const [walletClient] = await connection.viem.getWalletClients();
        if (walletClient === undefined) {
            throw new HardhatError(HardhatError.ERRORS.IGNITION.INTERNAL.NO_DEFAULT_VIEM_WALLET_CLIENT);
        }
        const viem = await import("viem");
        const contract = viem.getContract({
            address: _a.#ensureAddressFormat(deployedContract.address),
            abi: future.artifact.abi,
            client: {
                public: publicClient,
                wallet: walletClient,
            },
        });
        return contract;
    }
    static #ensureAddressFormat(address) {
        if (!address.startsWith("0x")) {
            return `0x${address}`;
        }
        return `0x${address.slice(2)}`;
    }
    static #resolveStrategyConfig(hardhatConfig, strategyName, strategyConfig) {
        if (strategyName === undefined) {
            return undefined;
        }
        if (strategyConfig === undefined) {
            const fromHardhatConfig = hardhatConfig.ignition?.strategyConfig?.[strategyName];
            return fromHardhatConfig;
        }
        return strategyConfig;
    }
}
_a = ViemIgnitionHelperImpl;
//# sourceMappingURL=viem-ignition-helper.js.map