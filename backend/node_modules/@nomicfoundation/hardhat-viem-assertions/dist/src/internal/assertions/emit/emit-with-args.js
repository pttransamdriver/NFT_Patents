import assert from "node:assert/strict";
import { assertHardhatInvariant } from "@nomicfoundation/hardhat-errors";
import { stringifyArgs } from "../../helpers.js";
import { isArgumentMatch } from "../../predicates.js";
import { handleEmit } from "./core.js";
export async function emitWithArgs(viem, contractFn, contract, eventName, expectedArgs) {
    const abiEvents = contract.abi.filter((item) => item.type === "event" &&
        item.name === eventName &&
        item.inputs.length === expectedArgs.length);
    assert.ok(abiEvents.length !== 0, `Event "${eventName}" with argument count ${expectedArgs.length} not found in the contract ABI`);
    assert.ok(abiEvents.length === 1, `There are multiple events named "${eventName}" that accepts ${expectedArgs.length} input arguments. This scenario is currently not supported.`);
    const expectedAbiEvent = abiEvents[0];
    const parsedLogs = await handleEmit(viem, contractFn, contract, eventName);
    for (const { args: logArgs } of parsedLogs) {
        let emittedArgs = [];
        if (logArgs === undefined) {
            if (expectedArgs.length === 0) {
                // If the logs contain no arguments and none are expected, we can return, this is a valid match
                return;
            }
            continue;
        }
        if (Array.isArray(logArgs)) {
            // All the expected args are listed in an array, this happens when some of the event parameters do not have parameter names.
            // Example: event EventX(uint u, uint) -> mapped to -> [bigint, bigint]
            emittedArgs = logArgs;
        }
        else {
            // The event parameters have names, so they are represented as an object.
            // They must be mapped into a sorted array that matches the order of the ABI event parameters.
            // Example: event EventY(uint u, uint v) -> mapped to -> { u: bigint, v: bigint }
            for (const [index, param] of expectedAbiEvent.inputs.entries()) {
                assertHardhatInvariant(param.name !== undefined, `The event parameter at index ${index} does not have a name`);
                emittedArgs.push(logArgs[param.name]);
            }
        }
        if (await isArgumentMatch(emittedArgs, expectedArgs)) {
            return;
        }
        if (parsedLogs.length === 1) {
            // Provide additional error details only if a single event was emitted
            if (expectedArgs.some((arg) => typeof arg === "function")) {
                // If there are predicate matchers, we can't use the built-in deepEqual with diff
                const displayExpectedArgs = expectedArgs.map((expectedArg) => {
                    if (typeof expectedArg === "function") {
                        const hasName = expectedArg.name !== undefined && expectedArg.name !== "";
                        return `<${hasName ? expectedArg.name : "predicate"}>`;
                    }
                    else {
                        return expectedArg;
                    }
                });
                assert.fail(`The event arguments do not match the expected ones:\nExpected: ${stringifyArgs(displayExpectedArgs)}\nEmitted: ${stringifyArgs(emittedArgs)}`);
            }
            else {
                // Otherwise, we can use it
                assert.deepEqual(emittedArgs, expectedArgs, "The event arguments do not match the expected ones.");
            }
        }
    }
    assert.fail("Multiple events were emitted, but none of them match the expected arguments.");
}
//# sourceMappingURL=emit-with-args.js.map